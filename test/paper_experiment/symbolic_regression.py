import jax
import jax.numpy as jnp
import numpy as np
from src.algorithm import GeneticProgramming as GP
from src.algorithm import DiscreteConst, BasicSelection, BasicCrossover, BasicMutation
from src.pipeline import General
from src.problem.func_fit import GeneralFuncFit

STEP_CNT = 4096
LOW_BOUNDS = jax.numpy.array([-5.0, -5.0])
UPPER_BOUNDS = jax.numpy.array([5.0, 5.0])


def main():
    alg = GP(
        pop_size=1000,
        num_inputs=2,
        num_outputs=1,
        crossover=BasicCrossover(),
        mutation=BasicMutation(),
        selection=BasicSelection(
            elite_rate=0.1,
            survive_rate=0.4,
        ),
        const=DiscreteConst(
            jax.numpy.array([-1., 0., 1.])
        ),
        leaf_prob=[0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
        max_len=32,
        max_sub_tree_len=8,
    )

    # create general function fitting problem and then initialize it
    # in this example, all data points are generated by sampling from a grid of 2D points
    prob = GeneralFuncFit(
        func=lambda x: (
                1 / (1 + jnp.power(x[0], -4)) +
                1 / (1 + jnp.power(x[1], -4))
        ),
        low_bounds=LOW_BOUNDS,
        upper_bounds=UPPER_BOUNDS,
    )

    prob.generate(
        method='grid',
        step_size=jax.numpy.array((UPPER_BOUNDS - LOW_BOUNDS) / STEP_CNT)
    )
    print("generate finish")
    pipeline = General(alg, prob)

    key = jax.random.PRNGKey(42)
    state = pipeline.setup(key)

    jit_step = jax.jit(pipeline.step)
    # pre step for jit compile
    _ = jit_step(state)

    import time

    for i in range(10):
        tic = time.time()
        state, fitnesses = jit_step(state)
        fitnesses = jax.device_get(fitnesses)
        toc = time.time()
        print(f'max: {np.max(fitnesses)}, min: {np.min(fitnesses)}, mean: {np.mean(fitnesses)}, time: {toc - tic}')


if __name__ == '__main__':
    main()
