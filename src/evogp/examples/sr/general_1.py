import sys

sys.path.append("/wuzhihong/TensorGP")
import jax
import jax.numpy as jnp
import numpy as np
from evogp.algorithm import DiscreteConst, GeneticProgramming as GP
from evogp.algorithm import BasicCrossover
from evogp.algorithm import (
    SubtreeMutation,
    HoistMutation,
    SinglePointMutation,
    LambdaPointMutation,
    InsertMutation,
    DeleteMutation,
)
from evogp.algorithm import (
    BasicSelection,
    TruncationSelection,
    RouletteSelection,
    RankSelection,
    TournamentSelection,
)
from evogp.pipeline import General
from evogp.problem.func_fit import GeneralFuncFit
import time

import os
os.environ["XLA_PYTHON_CLIENT_PREALLOCATE"] = "false"
os.environ["CUDA_VISIBLE_DEVICES"] = "0"
# os.environ["XLA_PYTHON_CLIENT_MEM_FRACTION"] = "0.8"

def main():
    alg = GP(
        pop_size=2000,
        num_inputs=2,
        num_outputs=1,
        max_len=1024,
        max_sub_tree_len=128,
        crossover=BasicCrossover(),
        crossover_rate=0.9,
        mutation=(
            SubtreeMutation(
                max_sub_tree_len=128,
                leaf_prob=[0, 0, 0,  0, 0.1, 0.2,   1,   1,   1,    1],
                # size   =[1, 3, 7, 15,  31,  63, 127, 255, 511, 1023]
                ),
        ),
        mutation_rate=(0.1,),
        selection=TournamentSelection(20, 0.9, False),
        const=DiscreteConst(
            jax.numpy.array(
                [-5.0, -4.0, -3.0, -2.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0]
            )
        ),
        leaf_prob=[0, 0, 0,  0, 0.1, 0.2, 0.4,   1,   1],
        # size   =[2, 4, 8, 16, 32,  64, 128, 256, 512, 1024]
    )

    # create general function fitting problem and then initialize it
    # in this example, all data points are generated by sampling from a grid of 2D points
    prob = GeneralFuncFit(
        func=lambda x: (x[0] ** 4 / (x[0] ** 4 + 1) + x[1] ** 4 / (x[1] ** 4 + 1)),
        low_bounds=jax.numpy.array([-5, -5]),
        upper_bounds=jax.numpy.array([5, 5]),
    )
    # prob.generate(
    #     method="sample",
    #     num_samples=8 * 8,
    # )
    prob.generate(
        method="grid",
        step_size=jax.numpy.array([2.5, 2.5]),
    )

    pipeline = General(alg, prob)

    key = jax.random.PRNGKey(1)
    state = pipeline.setup(key)

    jit_step = jax.jit(pipeline.step)
    # jit_step = pipeline.step

    # hlo_computation = jax.xla_computation(jit_step)(state)
    # hlo_text = hlo_computation.as_hlo_text()  # 将 HLO 转换为文本格式
    # with open('function.hlo', 'w') as file:
    #     file.write(hlo_text)  # 写入文件

    state, fitnesses = jit_step(state)
    print("--------initialization finished--------")

    start_time = time.time()
    for i in range(20):
        state, fitnesses = jit_step(state)
        print(i)

        # fitnesses = jax.device_get(fitnesses)
        # print(f"gen:{i}, max: {np.max(fitnesses)},", end=" ")
        # from evogp.cuda.utils import tree_size, from_cuda_node

        # trees = pipeline.algorithm.ask(state.alg_state)
        # print(f"mean_size: {np.mean(jax.vmap(tree_size)(trees))}")

        # print(from_cuda_node(trees))

    end_time = time.time()
    print(f"\nExecution time: {end_time - start_time:.3f} seconds")

    fitnesses = jax.device_get(fitnesses)
    print(f"pop:{alg.config['pop_size']}, max: {-np.max(fitnesses)},", end=" ")

    # start_time = time.time()
    # for i in range(20):
    #     state, fitnesses = jit_step(state)
    #     print(i)

    #     # fitnesses = jax.device_get(fitnesses)
    #     # print(f"gen:{i}, max: {np.max(fitnesses)},", end=" ")
    #     # from evogp.cuda.utils import tree_size, from_cuda_node

    #     # trees = pipeline.algorithm.ask(state.alg_state)
    #     # print(f"mean_size: {np.mean(jax.vmap(tree_size)(trees))}")

    #     # print(from_cuda_node(trees))

    # end_time = time.time()
    # print(f"\nExecution time: {end_time - start_time} seconds")

    # fitnesses = jax.device_get(fitnesses)
    # print(f"gen:{i}, max: {np.max(fitnesses)},", end=" ")

if __name__ == "__main__":
    main()
